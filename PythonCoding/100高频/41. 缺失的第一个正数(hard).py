# 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。
#
# 请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。
# 示例 1：
#
# 输入：nums = [1,2,0]
# 输出：3
# 示例 2：
#
# 输入：nums = [3,4,-1,1]
# 输出：2
# 示例 3：
#
# 输入：nums = [7,8,9,11,12]
# 输出：1


class Solution(object):
    # 整体思路，找到最小的正数，那么就可以假定最好的情况，在整体数组0...n-1位置上，放着1...n的数字
    # 此时用两个参数， l（当前位置之前已经实现了1...l-1的所有升序数字），
    # r（r以后的位置都是垃圾区）r的值代表从1开始升序的数字，最多就只能到r（因为原本数组长度为n，一些无效的数字存在，导致了，升序最好的情况到达不了n）
    # 最好的情况就是[1,2,3,4,5,6,7,8,9,10],0位置放1，i位置放i+1
    def firstMissingPositive(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        # l 代表0-l 范围内已经实现了1到i-1
        l = 0
        r = len(nums)
        while l < r:
            # 第一种情况，i位置放i+1 正确，l++
            if nums[l] == l + 1:
                l += 1
            # 如果nums[l] 比当前的l小等，比r大，说明是不需要的数字，交换r-1位置的数，
            # nums[l]-1 代表 当前数字应该去的iNdex，如果它应该去的位置已经有相同的它了 说明它是不需要的数字，交换r-1位置的数，进垃圾区
            elif nums[l] <= l or nums[l] > r or nums[nums[l]-1] == nums[l]:
                r -= 1
                nums[l], nums[r] = nums[r], nums[l]
            # 此时说明，nums[l]应该去的位置没有相同的它，交换一下，继续验证
            else:
                nums[nums[l]-1], nums[l] = nums[l], nums[nums[l]-1]
        # l（当前位置之前已经实现了1...l-1的所有升序数字）返回l+1代表当前位置应该有的正数值
        return l + 1
